import random

def similar_pair(n, k, edges):
    from collections import defaultdict

    # Construir a √°rvore
    tree = defaultdict(list)
    for parent, child in edges:
        tree[parent].append(child)

    # Encontrar a raiz (n√≥ que n√£o √© filho de ningu√©m)
    all_nodes = set(range(1, n + 1))
    children = set(child for _, child in edges)
    roots = list(all_nodes - children)
    root = roots[0] if roots else 1

    # DFS para contar pares similares
    def dfs(node, ancestors):
        count = 0
        for ancestor in ancestors:
            if abs(ancestor - node) <= k:
                count += 1
        for child in tree[node]:
            count += dfs(child, ancestors + [node])
        return count

    return dfs(root, [])

def generateTestCases():
    return [
        (5, 2, [(3, 2), (3, 1), (1, 4), (1, 5)]),
        (6, 3, [(1, 2), (1, 3), (2, 4), (3, 5), (3, 6)]),
        (4, 1, [(1, 2), (2, 3), (3, 4)]),
        (7, 4, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (6, 7)]),
        (3, 0, [(1, 2), (2, 3)])
    ]

def main():
    testCases = generateTestCases()
    for idx, (n, k, edges) in enumerate(testCases, 1):
        print(f"üß™ Teste {idx}")
        print(f"n = {n}, k = {k}, edges = {edges}")
        result = similar_pair(n, k, edges)
        print(f"‚û°Ô∏è Resultado: {result}\n")

if __name__ == "__main__":
    main()
